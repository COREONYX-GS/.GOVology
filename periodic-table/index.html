<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>.GOVology - Federal .gov Domain Search Tool</title>
  <style>
    /* Reset body margins */
    body {
      margin: 0;
      padding: 0;
    }
    /* Push the grid down so it's not overlapped by the search bar */
    svg {
      margin-top: 60px;
    }

    /* Hamburger container: fixed at top left with a reserved width */
    #hamburger-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 50px;
      padding: 10px;    
      box-sizing: border-box;
      z-index: 3100;
      /* border-right: 1px solid #ccc; */
      /* background: #fff; */
    }
    /* Hamburger icon styling (stays the same) */
    #hamburger-menu-icon {
      font-size: 24px;
      cursor: pointer;
    }
    /* Hamburger dropdown styling */
    #hamburger-menu {
      display: none; /* Hidden by default */
      position: absolute;
      top: 40px;  /* Adjust based on icon size; this positions it below the icon */
      left: 0;
      padding: 10px;
      border-radius: 4px; /* Added for consistency */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Added subtle shadow */
      background: rgba(255, 255, 255, 0.95); /* Semi-transparent white background */
      /* background: #fff; */
      /* border: 1px solid #ccc; */
      z-index: 3200;
    }
    /* Hamburger menu link styling */
    #hamburger-menu a {
      display: block;
      padding: 8px 0;
      color: #000;
      text-decoration: none;
    }
    #hamburger-menu a:hover {
      background: #1188ff;
      color: #fff;
    }

    /* Fixed search bar styling */
    #search-container {
      position: fixed;
      top: 0;
      left: 40px; /* Offset by the hamburger container width plus a little margin */
      right: 0;
      width: calc(100% - 9%); /* Adjust width accordingly */
      padding: 10px;
      box-sizing: border-box;
      border-bottom: 1px solid #ccc;
      /* background: #fff; */
      z-index: 3000;
    }
    #search-input {
      padding: 8px;
      font-size: 16px;
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #search-input:focus {
      outline: none;
      border-color: #0e77ac; /* Highlight border on focus */
      box-shadow: 0 0 5px rgba(83, 143, 173, 0.5); /* Subtle glow effect */
    }

    /* Autocomplete dropdown styling */
    #autocomplete-container {
      position: absolute;
      top: 50px; /* below the search bar */
      left: 10px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px; /* Added for consistency */
      width: calc(100% - 20px);
      max-height: 200px;
      overflow-y: auto;
      display: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Added subtle shadow */
      z-index: 3200;
    }
    .autocomplete-item {
      padding: 8px;
      cursor: pointer;
    }
    .autocomplete-item:hover,
    .autocomplete-item.active {
      background: #ddd;
    }

    /* Basic styling for the cells */
    .cell {
      stroke: #333;
      fill: #cfd8dc; /* light blue-grey */
      rx: 8;
      ry: 8;
      /* transition: fill 0.3s; */
    }
    .cell:hover {
      fill: #538fad; /* medium steel blue */
    }
    /* Text styling */
    text {
      pointer-events: none;
      font-size: 14px;
      fill: #000;
      font-weight: bold;  
      dominant-baseline: middle;
    }

    /* Tooltip styling */
    #tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #333;
      padding: 10px;
      font-size: 14px;
      pointer-events: none;
      display: none;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    /* Detail Card (Modal domain detail pop-out) styling */
    #detail-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 2px solid #333;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      display: none;
      border-radius: 8px; /* Added for a modern look */
      max-width: 90%;
      z-index: 2000;
    }
    #detail-card h2 {
      margin-top: 0;
      font-size: 20px;
    }
    #detail-card p {
      font-size: 16px;
    }
    #detail-card button {
      margin-top: 10px;
      padding: 5px 10px;
      font-size: 14px;
      background: #538fad;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #detail-card button:hover {
      background: #41728a;
      color: #333;
    }
    #detail-card #close-card {
      position: absolute;
      top: 10px;
      right: 10px;
      border: none;
      font-size: 14px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <div id="hamburger-container">
    <div id="hamburger-menu-icon">&#9776;</div>
    <!-- Hamburger Menu Dropdown -->
    <div id="hamburger-menu">
      <a id="menu-about" href="#">About</a>
      <a id="menu-github" href="https://github.com/COREONYX-GS/.GOVology">GitHub</a>
    </div>
  </div>

  <!-- Fixed Search Bar -->
  <div id="search-container">
    <!-- Search Input -->
    <input id="search-input" type="text" autocomplete="off" placeholder="Search... e.g. agency:&quot;Department of Energy&quot; org:&quot;Energy Information Administration&quot; is:acronym" />
    <!-- Autocomplete Container -->
    <div id="autocomplete-container"></div>
  </div>
  
  <svg id="visualization"></svg>
  
  <!-- Tooltip for hover interactions -->
  <div id="tooltip"></div>
  
  <!-- Detail Card for click interactions -->
  <div id="detail-card">
    <h2 id="card-title"></h2>
    <p id="card-content"></p>
    <button id="close-card">X</button>
  </div>
  
  <!-- d3.js from a CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script defer>
    const cellWidth = 160;
    const cellHeight = 40;
    const padding = 5;      // Padding around total visualization, not intra-cell padding
  
    let uniqueAgencies = [];
    let uniqueOrgs = [];
    let globalData;
    let currentSuggestionIndex = -1;  // Track the current autocomplete selection

    // Load data and initialize.
    d3.json("../data/gov-elements.json").then(data => {
      globalData = data;
      buildUniqueLists(globalData);
      applyURLParameters();
      applyFiltersAndRedraw();
    }).catch(error => {
      console.error("Error loading data:", error);
    });

    function parseLengthFilter(input) {
      const match = input.match(/^([!<>]?)(\d+)$/);
      if (!match) {
        return { operator: "", value: NaN };
      }
      // FIXME: Can you set default values in regexp? like if operator is "" use "="
      // FIXME: should we return { operator: null, value: null} if no match?
      return {
        operator: match[1],
        value: parseInt(match[2], 10)
      };
    }

    function matchesLength(domain, { operator, value }) {
      const len = domain.length;
      switch (operator) {
        case "":  return len === value;
        case "=":  return len === value;
        case "!": return len !== value;
        case "<": return len < value;
        case ">": return len > value;
        default:  return false;
      }
    }

    // Filter function supporting free text, agency:"", and org:"" filters.
    function filterData(query, data) {
      query = query.toLowerCase();
      // Regex to match tokens (including quoted values)
      const tokens = query.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
      const freeTokens = [];
      const agencyTokens = [];
      const orgTokens = [];
      const isTokens = [];
      const lengthTokens = []
      
      //console.log("Filter Query: " + query);
      //console.log("Filter Tokens: " + tokens);

      tokens.forEach(token => { // parse tokens and add them to filters
        const cleaned = token.replace(/"/g, '');
        // Or remove only the surrounding quotes (if any) rather than all quotes.
        // const cleaned = token.replace(/^"|"$/g, ''); // Note, this probably isn't necessary since I don't think any domains (or data) have quotes in them 

        if (cleaned.startsWith("agency:")) {
          const val = cleaned.slice("agency:".length).trim();
          if (val) agencyTokens.push(val);
        }
        else if (cleaned.startsWith("org:")) {
          const val = cleaned.slice("org:".length).trim();
          if (val) orgTokens.push(val);
        } 
        else if (cleaned.startsWith("is:")) {
            const val = cleaned.slice("is:".length).trim();
            if (val) isTokens.push(val);
        }
        else if (cleaned.startsWith("len:")) {
            const val = cleaned.slice("len:".length).trim();
            if (val) lengthTokens.push(val);
        }
        else {
          freeTokens.push(cleaned); // Search based on free text as a token - not only in domain name (e.g. not org or agency)
        }
      });
      
      return data.filter(d => { // Compare lower case values
        const domain = (d.domain || "").toLowerCase();
        const agency = (d.agency || "").toLowerCase();
        const org = (d.org || "").toLowerCase();

        const freeMatch = freeTokens.every(token => domain.includes(token)); // FIXME: Consider if this should search org and agency as well
        const agencyMatch = agencyTokens.length === 0 || agencyTokens.some(token => agency.includes(token));
        const orgMatch = orgTokens.length === 0 || orgTokens.some(token => org.includes(token));            

        const isMatch = isTokens.every(token => {
          const value = d[`is_${token}`];
          if (typeof value === "object" && value !== null) {
            return Object.keys(value).length > 0; // Check if the object has any entries
          }
          return Boolean(value); // Handle non-object values e.g. `!!value`;
        });
        
        const lenMatch = lengthTokens.every(token => matchesLengthFilter(domain, token)); // FIXME: Note this parses the regexp every time, could optimize if needed
        return freeMatch && agencyMatch && orgMatch && isMatch && lenMatch;
      });
    }

    // Draw or redraw grid based on provided data.
    function drawGrid(drawData) {
      const svg = d3.select("#visualization");
      svg.selectAll("*").remove();

      const availableWidth = window.innerWidth - (padding * 2);
      const numColumns = Math.floor(availableWidth / cellWidth);
      const numRows = Math.ceil(drawData.length / numColumns);
      const svgWidth = (cellWidth * numColumns) + padding * 2;
      const svgHeight = (cellHeight * numRows) + padding * 2;
      
      svg.attr("width", svgWidth).attr("height", svgHeight);
      const tooltip = d3.select("#tooltip");
      
      svg.selectAll("rect")
          .data(drawData)
          .enter()
          .append("rect")
          .attr("class", "cell")
          .attr("x", (d, i) => padding + (i % numColumns) * cellWidth)
          .attr("y", (d, i) => padding + Math.floor(i / numColumns) * cellHeight)
          .attr("width", cellWidth)
          .attr("height", cellHeight)
          .on("mouseover", function(event, d) {
              const isAttributes = Object.keys(d)
              .filter(key => key.startsWith("is_"))
              .map(key => {
                  if (Array.isArray(d[key])) {
                  const items = d[key].join(", ");
                  return `<strong>${key}:</strong>[${items}]`;
                  } else if (typeof d[key] === "object") {
                  const words = Object.entries(d[key])
                  .map(([k, v]) => `${k} (${v})`)
                  .join(", ");
                  return `<strong>${key}:</strong> ${words}`;
                  } else {
              return `<strong>${key}:</strong> ${d[key]}`;
              }
              })
              .join("<br>");
              tooltip.style("display", "block") // This is where the content for the 'hover' tooltip is created
              .html(`<strong>${d.domain}.gov</strong><br><br><b>agency:</b>"${d.agency}"<br><b>organization:</b>"${d.org}"<br><b>len:</b> ${d["length"]}<br>${isAttributes}`);
              })
          .on("mousemove", function(event) {
              tooltip.style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY + 10) + "px");
          })
          .on("mouseout", function() {
              tooltip.style("display", "none");
          })
          .on("click", function(event, d) {
          const isAttributes = Object.keys(d)
          .filter(key => key.startsWith("is_"))
          .map(key => {
              if (Array.isArray(d[key])) {
              const items = d[key].join(", ");
              return `<strong>${key}:</strong> [${items}]`;
             } else if (typeof d[key] === "object") {
              const words = Object.entries(d[key])
              .map(([k, v]) => `${k} (${v})`)
              .join(", ");
              return `<strong>${key}:</strong> ${words}`;
             } else {
           return `<strong>${key}:</strong> ${d[key]}`;
           }
         })
         .join("<br>");
           d3.select("#card-title")
         .html(`<a href="https://${d.domain}.gov" target="_blank">${d.domain}.gov</a>`);
           d3.select("#card-content").html(
         `<strong>Agency:</strong> ${d.agency}<br><strong>Organization:</strong> ${d.org}<br>${isAttributes}`
           );
           d3.select("#detail-card").style("display", "block");
         });
      svg.selectAll("text")
        .data(data)
        .enter()
        .append("text")
        .attr("x", (d, i) => padding + (i % numColumns) * cellWidth + cellWidth / 2)
        .attr("y", (d, i) => padding + Math.floor(i / numColumns) * cellHeight + cellHeight / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("font-size", d => {
          const len = d.domain.length;
          return len > 18 ? "10px"
                : len > 14 ? "12px"
                : "14px";
        })
        .text(d => d.domain);
    }

    // Build unique lists of agencies and organizations.
    function buildUniqueLists(data) {
      const agencies = new Set();
      const orgs = new Set();
      data.forEach(d => {
        if (d.agency) agencies.add(d.agency);
        if (d.org) orgs.add(d.org);
      });
      uniqueAgencies = Array.from(agencies);
      uniqueOrgs = Array.from(orgs);
    }

    // Show autocomplete suggestions for a given filter type ("agency" or "org")
    function showAutocomplete(filterType, partial) {
      const container = d3.select("#autocomplete-container");
      let suggestions = [];
      if (filterType === "agency") {
        suggestions = uniqueAgencies.filter(a => a.toLowerCase().includes(partial.toLowerCase()));
      } else if (filterType === "org") {
        suggestions = uniqueOrgs.filter(o => o.toLowerCase().includes(partial.toLowerCase()));
      }
      if (suggestions.length === 0) {
        container.style("display", "none");
        currentSuggestionIndex = -1;
        return;
      }
      container.style("display", "block");
      container.html(""); // Clear previous suggestions.
      suggestions.forEach((suggestion, index) => {
        container.append("div")
          .attr("class", "autocomplete-item")
          .attr("data-index", index)
          .text(suggestion)
          .on("click", () => {
            completeFilter(filterType, suggestion);
          });
      });
      // Reset selection index when new suggestions are shown.
      currentSuggestionIndex = -1;
    }

    // Helper function to update the visual highlight of autocomplete items.
    function updateActiveSuggestion(suggestions, index) {
      suggestions.each(function(d, i) {
        d3.select(this).classed("active", i === index);
      });
    }

    // Complete the filter token using the provided suggestion.
    function completeFilter(filterType, suggestion) {
      let current = d3.select("#search-input").property("value");
      const regex = new RegExp(`(${filterType}:"?)([^"]*)$`, "i");
      current = current.replace(regex, `$1${suggestion}"`);
      d3.select("#search-input").property("value", current);
      d3.select("#autocomplete-container").style("display", "none");
      const filteredData = filterData(current, globalData);
      drawGrid(filteredData);
      currentSuggestionIndex = -1;
    }

    // Auto-insert matching quotes for agency: and org: filters.
    function autoInsertQuotes(e) {
      const input = e.target;
      let value = input.value;
      // const agencyPattern = /agency:(?!")(\S+)/i;
      const agencyPattern = /agency:([^\s"]*)$/i;
      if (agencyPattern.test(value)) {
        value = value.replace(agencyPattern, 'agency:"$1');
        input.value = value;
      }
      // const orgPattern = /org:(?!")(\S+)/i;
      const orgPattern = /org:([^\s"]*)$/i;
      if (orgPattern.test(value)) {
        value = value.replace(orgPattern, 'org:"$1');
        input.value = value;
      }
    }

    const searchInput = d3.select("#search-input");
    searchInput
      .on("input", function(event) {
        autoInsertQuotes(event);
        const query = this.value;

        // Check for filters
        const agencyMatch = query.match(/agency:"([^"]*)$/i);
        if (agencyMatch) {
          showAutocomplete("agency", agencyMatch[1]);
        } else {
          const orgMatch = query.match(/org:"([^"]*)$/i);
          if (orgMatch) {
            showAutocomplete("org", orgMatch[1]);
          } else {
            d3.select("#autocomplete-container").style("display", "none");
            currentSuggestionIndex = -1;
          }
        }
        const filteredData = query.trim() === ""
          ? globalData
          : filterData(query, globalData);
        drawGrid(filteredData);
      })
      .on("keydown", function(event) {
        const container = d3.select("#autocomplete-container");
        if (container.style("display") !== "none") {
          const suggestions = container.selectAll(".autocomplete-item");
          if (event.key === "ArrowDown") {
            const count = suggestions.size();
            currentSuggestionIndex = (currentSuggestionIndex + 1) % count;
            updateActiveSuggestion(suggestions, currentSuggestionIndex);
            event.preventDefault();
          } else if (event.key === "ArrowUp") {
            const count = suggestions.size();
            currentSuggestionIndex = (currentSuggestionIndex - 1 + count) % count;
            updateActiveSuggestion(suggestions, currentSuggestionIndex);
            event.preventDefault();
          } else if (event.key === "Enter" || event.key === "Tab") {
            if (currentSuggestionIndex !== -1) {
              const firstSuggestion = suggestions.filter((d, i) => i === currentSuggestionIndex).text();
              if (firstSuggestion) {
                // Determine filter type based on current query.
                let current = d3.select(this).property("value");
                let filterType = "";
                if (/agency:"[^"]*$/.test(current)) {
                  filterType = "agency";
                } else if (/org:"[^"]*$/.test(current)) {
                  filterType = "org";
                }
                if (filterType) {
                  completeFilter(filterType, firstSuggestion);
                  event.preventDefault();
                }
              }
            }
          }
        }
      });

    // Close autocomplete if clicking outside the search input.
    d3.select("body").on("click", function(event) {
      if (event.target.id !== "search-input") {
        d3.select("#autocomplete-container").style("display", "none");
        currentSuggestionIndex = -1;
      }
    });



    window.addEventListener("resize", () => {
      if (globalData) drawGrid(globalData);
    });

    d3.select("#close-card").on("click", () => {
      d3.select("#detail-card").style("display", "none");
    });

    // Check for query parameters on page load and trigger a search accordingly.
  function applyURLParameters() {
    const urlParams = new URLSearchParams(window.location.search);
    let query = "";
    
    // If a 'search' parameter is provided, use it as the starting query.
    const searchParam = urlParams.get("search");
    if (searchParam) {
      query += searchParam;
    }
    
    // If an 'agency' parameter is provided, append it with the proper syntax.
    const agencyParam = urlParams.get("agency");
    if (agencyParam) {
      // If query isnâ€™t empty, add a space first.
      query += (query ? " " : "") + `agency:"${agencyParam}"`;
    }
    
    // Similarly, check for an 'org' parameter.
    const orgParam = urlParams.get("org");
    if (orgParam) {
      query += (query ? " " : "") + `org:"${orgParam}"`;
    }
    
    // If the query is not empty, set the search input's value and trigger filtering.
    if (query.trim() !== "") {
      d3.select("#search-input").property("value", query.trim());
      // Trigger the input event to update the grid based on the query.
      d3.select("#search-input").dispatch("input");
    }
  }

  function updateSearchURL() {
    const query = d3.select("#search-input").property("value");
    const url = new URL(window.location.href);
    if (query.trim() === "") {
      // Remove the search parameter if the query is empty.
      url.searchParams.delete("search");
    } else {
      // Set the search parameter to the input value.
      url.searchParams.set("search", query);
    }
    // Update the URL without reloading the page.
    window.history.replaceState({}, '', url);
  }

  /// Toggle hamburger menu when clicking the icon.
  d3.select("#hamburger-menu-icon").on("click", function() {
    const menu = d3.select("#hamburger-menu");
    const currentDisplay = menu.style("display");
    menu.style("display", currentDisplay === "none" || currentDisplay === "" ? "block" : "none");
  });

  // Example callback for the "About" item.
  d3.select("#menu-about").on("click", function() {
    alert("This project visualizes government domains.\n\nSupported search syntax includes:\n- agency:\"...\" (e.g., agency:\"Department of Energy\")\n- org:\"...\" (e.g., org:\"Some Org\")\n- is:... (e.g., is:acronym)\n\nNote: Quotation marks are required for multi-word values.\n\nPlease visit GitHub for more info or to suggest updates.");
    d3.select("#hamburger-menu").style("display", "none");
  });

  // Callback for the "Sankey" menu item.
  d3.select("#menu-sankey").on("click", function() {
    if (globalData) {
      drawSankey(globalData);
    }
    d3.select("#hamburger-menu").style("display", "none");
  });

  // Callback for the "Cubes" menu item (resets to current grid view).
  d3.select("#menu-cubes").on("click", function() {
    if (globalData) {
      drawGrid(globalData);
    }
    d3.select("#hamburger-menu").style("display", "none");
  });


  </script>
</body>
</html>
